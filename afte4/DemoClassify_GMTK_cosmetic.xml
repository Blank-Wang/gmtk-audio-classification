<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="DemoClassify_GMTK_cosmetic" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={32, 22, 1408, 878}, maximized=true}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[1174, 768]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.000000000000004">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{692.8142169331395, -128.98704578488372}">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-65.0, -385.0}">
        </property>
    </property>
    <property name="stopAt" class="ptolemy.data.expr.Parameter" value="10000.0">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{25.0, -405.0}">
        </property>
    </property>
    <property name="enableBackwardTypeInference" class="ptolemy.data.expr.Parameter" value="true">
    </property>
    <property name="LocalPreferences" class="ptolemy.actor.gui.PtolemyPreferences">
        <property name="backgroundColor" class="ptolemy.actor.gui.ColorAttribute" value="{1,1,1,1}">
            <display name="Background Color"/>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{70, 260}">
        </property>
    </property>
    <entity name="FeatureExtraction" class="ptolemy.actor.TypedCompositeActor">
        <property name="_location" class="ptolemy.kernel.util.Location" value="{145.0, -285.0}">
        </property>
        <property name="windowSize" class="ptolemy.data.expr.Parameter" value="1024">
            <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
                <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
                </property>
            </property>
            <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
                <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
            </property>
            <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{285.0, -65.0}">
            </property>
        </property>
        <property name="LPcoefficients" class="ptolemy.data.expr.Parameter" value="5">
            <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
                <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
                </property>
            </property>
            <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
                <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
            </property>
            <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{150.0, -65.0}">
            </property>
        </property>
        <property name="SDF Director" class="ptolemy.domains.sdf.kernel.SDFDirector">
            <property name="iterations" class="ptolemy.data.expr.Parameter" value="AUTO">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{60.0, -45.0}">
            </property>
        </property>
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={82, 22, 934, 634}, maximized=false}">
        </property>
        <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 524]">
        </property>
        <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0">
        </property>
        <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{687.8492914244187, 102.9762445494186}">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.EditorIcon">
            <property name="rectangle" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[0.0, -1.0]">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="60">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="40">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 1.0, 1.0, 1.0}">
                </property>
            </property>
            <property name="arc" class="ptolemy.vergil.kernel.attributes.ArcAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="-20.999999999999996, -5.231236744646286">
                </property>
                <property name="lineColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.2,0.6,0.0,1.0}">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="14.549230741244456">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="30.162633281564762">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 1.0, 1.0, 1.0}">
                </property>
                <property name="type" class="ptolemy.data.expr.StringParameter" value="open">
                </property>
                <property name="start" class="ptolemy.data.expr.Parameter" value="10.0">
                </property>
                <property name="extent" class="ptolemy.data.expr.Parameter" value="150.0">
                </property>
            </property>
            <property name="arc2" class="ptolemy.vergil.kernel.attributes.ArcAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="-7.499999999999999, 6.272584937777628">
                </property>
                <property name="lineColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.2,0.6,0.0,1.0}">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="13.50999997401271">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="25.522228161324033">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 1.0, 1.0, 1.0}">
                </property>
                <property name="type" class="ptolemy.data.expr.StringParameter" value="open">
                </property>
                <property name="start" class="ptolemy.data.expr.Parameter" value="-20.0">
                </property>
                <property name="extent" class="ptolemy.data.expr.Parameter" value="-150.0">
                </property>
            </property>
            <property name="Arrow" class="ptolemy.vergil.kernel.attributes.ArrowAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[6.0, -1.0]">
                </property>
                <property name="x" class="ptolemy.data.expr.Parameter" value="-15.0">
                </property>
                <property name="y" class="ptolemy.data.expr.Parameter" value="0.0">
                </property>
                <property name="arrowLength" class="ptolemy.data.expr.Parameter" value="5.0">
                </property>
                <property name="arrowWidth" class="ptolemy.data.expr.Parameter" value="4.0">
                </property>
            </property>
            <property name="rectangle2" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="18.0, -0.5">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="12.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="37.0">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.6,0.8,1.0,1.0}">
                </property>
                <property name="rounding" class="ptolemy.data.expr.Parameter" value="10.0">
                </property>
            </property>
            <property name="ellipse" class="ptolemy.vergil.kernel.attributes.EllipseAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[18.0, -13.0]">
                </property>
                <property name="lineWidth" class="ptolemy.data.expr.Parameter" value="0.5">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="7.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="7.0">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.8,1.0,0.8,1.0}">
                </property>
            </property>
            <property name="ellipse2" class="ptolemy.vergil.kernel.attributes.EllipseAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[18.0, -4.0]">
                </property>
                <property name="lineWidth" class="ptolemy.data.expr.Parameter" value="0.5">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="7.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="7.0">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.8,1.0,0.8,1.0}">
                </property>
            </property>
            <property name="ellipse3" class="ptolemy.vergil.kernel.attributes.EllipseAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[18.0, 5.0]">
                </property>
                <property name="lineWidth" class="ptolemy.data.expr.Parameter" value="0.5">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="7.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="7.0">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.8,1.0,0.8,1.0}">
                </property>
            </property>
            <property name="ellipse4" class="ptolemy.vergil.kernel.attributes.EllipseAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[18.0, 13.0]">
                </property>
                <property name="lineWidth" class="ptolemy.data.expr.Parameter" value="0.5">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="7.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="7.0">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.8,1.0,0.8,1.0}">
                </property>
            </property>
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={253, 133, 934, 634}, maximized=false}">
            </property>
            <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 524]">
            </property>
            <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="4.0">
            </property>
            <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{12.5, 9.25}">
            </property>
        </property>
        <port name="port_1" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{825.0, 40.0}">
            </property>
        </port>
        <port name="port_4" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{20.0, 30.0}">
            </property>
        </port>
        <entity name="Expression" class="ptolemy.actor.lib.Expression">
            <property name="expression" class="ptolemy.kernel.util.StringAttribute" value="generateHammingWindow(windowSize)*in">
            </property>
            <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="expression">
                </property>
                <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="60">
                </property>
                <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
                </property>
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{325.0, 40.0}">
            </property>
            <port name="in" class="ptolemy.actor.TypedIOPort">
                <property name="input"/>
            </port>
        </entity>
        <entity name="SequenceToArray" class="ptolemy.domains.sdf.lib.SequenceToArray">
            <property name="arrayLength" class="ptolemy.actor.parameters.PortParameter" value="windowSize">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{95.0, 40.0}">
            </property>
        </entity>
        <entity name="Autocorrelation" class="ptolemy.domains.sdf.lib.Autocorrelation">
            <property name="numberOfInputs" class="ptolemy.data.expr.Parameter" value="windowSize">
            </property>
            <property name="numberOfLags" class="ptolemy.data.expr.Parameter" value="LPcoefficients">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{630.0, 40.0}">
            </property>
        </entity>
        <entity name="ArrayToSequence" class="ptolemy.domains.sdf.lib.ArrayToSequence">
            <property name="arrayLength" class="ptolemy.data.expr.Parameter" value="windowSize">
            </property>
            <property name="enforceArrayLength" class="ptolemy.data.expr.Parameter" value="false">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{515.0, 40.0}">
            </property>
        </entity>
        <entity name="LevinsonDurbin" class="ptolemy.actor.lib.LevinsonDurbin">
            <property name="_location" class="ptolemy.kernel.util.Location" value="{740.0, 40.0}">
            </property>
        </entity>
        <relation name="relation5" class="ptolemy.actor.TypedIORelation">
            <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;Autocorrelation.output&quot;,x=630.0,y=40.0}, tail={id=&quot;LevinsonDurbin.autocorrelation&quot;,x=740.0,y=40.0}, points={} } }">
            </property>
        </relation>
        <relation name="relation7" class="ptolemy.actor.TypedIORelation">
            <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;Expression.output&quot;,x=325.0,y=40.0}, tail={id=&quot;ArrayToSequence.input&quot;,x=515.0,y=40.0}, points={} } }">
            </property>
        </relation>
        <relation name="relation" class="ptolemy.actor.TypedIORelation">
            <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;Autocorrelation.input&quot;,x=630.0,y=40.0}, tail={id=&quot;ArrayToSequence.output&quot;,x=515.0,y=40.0}, points={} } }">
            </property>
        </relation>
        <relation name="relation3_4" class="ptolemy.actor.TypedIORelation">
            <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;port_4._location&quot;,x=20.0,y=30.0}, tail={id=&quot;SequenceToArray.input&quot;,x=95.0,y=40.0}, points={} } }">
            </property>
        </relation>
        <relation name="relation3" class="ptolemy.actor.TypedIORelation">
            <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
            </property>
            <vertex name="vertex1" value="{170.0, 40.0}">
            </vertex>
            <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;Expression.in&quot;,x=325.0,y=40.0}, tail={id=&quot;relation3.vertex1&quot;,x=170.0,y=40.0}, points={} },{ head={id=&quot;SequenceToArray.output&quot;,x=95.0,y=40.0}, tail={id=&quot;relation3.vertex1&quot;,x=170.0,y=40.0}, points={} } }">
            </property>
        </relation>
        <relation name="relation2" class="ptolemy.actor.TypedIORelation">
            <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
            </property>
            <vertex name="vertex1" value="[785.0, 40.0]">
            </vertex>
        </relation>
        <link port="port_1" relation="relation2"/>
        <link port="port_4" relation="relation3_4"/>
        <link port="Expression.output" relation="relation7"/>
        <link port="Expression.in" relation="relation3"/>
        <link port="SequenceToArray.input" relation="relation3_4"/>
        <link port="SequenceToArray.output" relation="relation3"/>
        <link port="Autocorrelation.input" relation="relation"/>
        <link port="Autocorrelation.output" relation="relation5"/>
        <link port="ArrayToSequence.input" relation="relation7"/>
        <link port="ArrayToSequence.output" relation="relation"/>
        <link port="LevinsonDurbin.autocorrelation" relation="relation5"/>
        <link port="LevinsonDurbin.linearPredictor" relation="relation2"/>
    </entity>
    <entity name="DiscreteClock" class="ptolemy.actor.lib.DiscreteClock">
        <property name="period" class="ptolemy.actor.parameters.PortParameter" value="1.0/44100">
        </property>
        <doc>Create periodic timed events.</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-65.0, -285.0}">
        </property>
    </entity>
    <entity name="Expression" class="ptolemy.actor.lib.Expression">
        <property name="expression" class="ptolemy.kernel.util.StringAttribute" value="{}">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="expression">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="60">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{270.0, -285.0}">
        </property>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_type" class="ptolemy.actor.TypeAttribute" value="arrayType(int)">
            </property>
        </port>
        <port name="in" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="CreateGMTKFeatureVector" class="ptolemy.actor.lib.ElementsToArray">
        <property name="_location" class="ptolemy.kernel.util.Location" value="{375.0, -285.0}">
        </property>
    </entity>
    <entity name="TokenToJSON" class="ptolemy.actor.lib.conversions.json.TokenToJSON">
        <property name="_location" class="ptolemy.kernel.util.Location" value="{625.0, -195.0}">
        </property>
    </entity>
    <entity name="Merge" class="ptolemy.domains.de.lib.Merge">
        <property name="_location" class="ptolemy.kernel.util.Location" value="{560.0, -195.0}">
        </property>
    </entity>
    <entity name="AudioCapture" class="ptolemy.actor.lib.javasound.AudioCapture">
        <property name="sampleRate" class="ptolemy.actor.parameters.SharedParameter" value="44100">
            <property name="style" class="ptolemy.actor.gui.style.ChoiceStyle">
                <property name="8000" class="ptolemy.kernel.util.StringAttribute" value="8000">
                </property>
                <property name="11025" class="ptolemy.kernel.util.StringAttribute" value="11025">
                </property>
                <property name="22050" class="ptolemy.kernel.util.StringAttribute" value="22050">
                </property>
                <property name="44100" class="ptolemy.kernel.util.StringAttribute" value="44100">
                </property>
                <property name="48000" class="ptolemy.kernel.util.StringAttribute" value="48000">
                </property>
            </property>
        </property>
        <property name="bitsPerSample" class="ptolemy.actor.parameters.SharedParameter" value="16">
            <property name="style" class="ptolemy.actor.gui.style.ChoiceStyle">
                <property name="8" class="ptolemy.kernel.util.StringAttribute" value="8">
                </property>
                <property name="16" class="ptolemy.kernel.util.StringAttribute" value="16">
                </property>
            </property>
        </property>
        <property name="channels" class="ptolemy.actor.parameters.SharedParameter" value="1">
            <property name="style" class="ptolemy.actor.gui.style.ChoiceStyle">
                <property name="1" class="ptolemy.kernel.util.StringAttribute" value="1">
                </property>
                <property name="2" class="ptolemy.kernel.util.StringAttribute" value="2">
                </property>
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{45.0, -285.0}">
        </property>
    </entity>
    <entity name="WebSocketClient" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor sends and/or receives messages from a web socket at&#10; *  the specified host and port. In `initialize()`, it&#10; *  begins connecting to the web socket server.&#10; *  Once the connection is established, a `true` boolean is sent to&#10; *  the `connected` output.&#10; *  If connection is not established immediately, the accessor will attempt to&#10; *  reconnect (numberOfRetries) times at an interval of (reconnectInterval)&#10; *&#10; *  Whenever an input is received on the `toSend`&#10; *  input, the message is sent to the socket. If the socket is not yet open,&#10; *  this accessor will, by default, queue the message to send when the socket opens,&#10; *  unless the `discardMessagesBeforeOpen` parameter is true, in which case,&#10; *  input messages that are received before the socket is opened will be&#10; *  discarded. If messages are queued and `throttleFactor` is non-zero, then&#10; *  whenever a message is queued to be later sent, the accessor will stall&#10; *  by a number of milliseconds given by the queue size times the throttleFactor.&#10; *  The longer the queue, the longer the stall. Note that this will likely block&#10; *  the host from executing, so this feature should be used with caution.&#10; *&#10; *  Whenever a message is received from the socket, that message is&#10; *  produced on the `'received'` output.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  connection.&#10; *  &#10; *  If the connection is dropped midway, the client will attempt to reconnect if &#10; *  (reconnectOnClose) is true. This does not apply when the accessor wraps up. &#10; *&#10; *  The data can be any type that has a JSON representation.&#10; *  For incoming messages, this accessor assumes that the message is&#10; *  a string in UTF-8 that encodes a JSON object.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *  &#10; *  # First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  # Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *  &#10; *  The server might similarly lose messages by the same two mechanisms occurring&#10; *  on the server side. In that case, messages will presumably be displayed on the&#10; *  server side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent. See `RosPublisher.js` for an example.&#10; *&#10; *  This accessor requires the 'webSocket' module.&#10; *&#10; *  @accessor WebSocketClient&#10; *  @parameter {string} server The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @parameter {int} port The port that the web socket listens to. Defaults to 8080.&#10; *  @parameter {int} numberOfRetries The number of times to retry if a connection fails. Defaults to 5.&#10; *  @parameter {int} timeBetweenRetries The time between retries in milliseconds. Defaults to 100.&#10; *  @parameter {boolean} reconnectOnClose The option of whether or not to reconnect when disconnected.&#10; *  @parameter {boolean} discardMessagesBeforeOpen If true, then any messages received on `toSend` before the socket is open will be discarded. This defaults to false.&#10; *  @parameter {int} throttleFactor If non-zero, specifies a time (in milliseconds) to stall when a message is queued because the socket is not yet open. The time of the stall will be the queue size (after adding the message) times the throttleFactor. This defaults to 0.&#10; *  @input toSend The data to be sent over the socket.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *  @author Hokeun Kim, Marcus Pan, Edward A. Lee, Matt Weber&#10; *  @version $$Id: WebSocketClient.js 245 2015-08-04 18:32:13Z matt.weber $$&#10; */&#10;&#10;var WebSocket = require('webSocket');&#10;var client = null;&#10;var inputHandle = null;&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function() {&#10;  parameter('server', {&#10;    type: 'string',&#10;    value: 'localhost'&#10;  });&#10;  parameter('port', {&#10;    type: 'int',&#10;    value: 8080&#10;  });&#10;  parameter('numberOfRetries', {&#10;    type: 'int',&#10;    value: 5&#10;  });&#10;  parameter('timeBetweenRetries', {&#10;    type: 'int',&#10;    value: 100&#10;  });&#10;  parameter('reconnectOnClose', {&#10;    type: 'boolean',&#10;    value: true&#10;  });&#10;  parameter('discardMessagesBeforeOpen', {&#10;    type: 'boolean',&#10;    value: false&#10;  });&#10;  parameter('throttleFactor', {&#10;    type: 'int',&#10;    value: 0&#10;  });&#10;  input('toSend');&#10;  output('connected', {&#10;    type: 'boolean'&#10;  });&#10;  output('received');&#10;}&#10;&#10;/** Initializes accessor by attaching functions to inputs. */&#10;exports.initialize = function() {&#10;  &#10;  //record the object that calls it (could be a derived accessor). &#10;  var callObj = this;&#10;   &#10;  client = new WebSocket.Client({&#10;    'host':getParameter('server'),&#10;    'port':getParameter('port'),&#10;    'numberOfRetries':getParameter('numberOfRetries'),&#10;    'timeBetweenRetries':getParameter('timeBetweenRetries'),&#10;    'discardMessagesBeforeOpen':getParameter('discardMessagesBeforeOpen'),&#10;    'throttleFactor':getParameter('throttleFactor')&#10;  });&#10;  &#10;  client.on('open', this.onOpen);&#10;  client.on('message', this.onMessage);&#10;&#10;  //bind onClose() to caller's object, &#10;  //so initialize() of caller's object is called if reconnect is true.&#10;  client.on('close', onClose.bind(callObj));&#10;  client.on('error', function(message) {&#10;    error(message)&#10;  });&#10;  //only execute once, and not when trying to reconnect. &#10;  if (inputHandle == null) { &#10;      inputHandle = addInputHandler('toSend', this.toSendInputHandler);&#10;  }&#10;} &#10;&#10;/** Handles input on 'toSend'. */&#10;exports.toSendInputHandler = function() {&#10;  exports.sendToWebSocket(get('toSend'));&#10;}&#10;&#10;/** Sends JSON data to the web socket. */&#10;exports.sendToWebSocket = function(data) {&#10;  if (client != null) {&#10;    client.send(data);&#10;    console.log(&quot;Sending to web socket: &quot; + JSON.stringify(data));&#10;  } else {&#10;    console.log(&quot;Client is null. Could not send message: &quot; + JSON.stringify(data)); &#10;  }&#10;}&#10;&#10;/** Executes once  web socket establishes a connection.&#10; *   Sets 'connected' output to true.&#10; */&#10;exports.onOpen = function() {&#10;   console.log('Status: Connection established');&#10;   send('connected', true);&#10;}&#10;  &#10;/** Send false to 'connected' output, and if 'reconnectOnClose'&#10; *  parameter evaluates to true and wrapup() has not been called,&#10; *  then invoke initialize().&#10; *  This will be called if either side closes the connection.&#10; *  @param message Possible message about the closure.&#10; */&#10;function onClose(message) {&#10;  console.log('Status: Connection closed: ' + message);&#10;  if (inputHandle) {&#10;    // wrapup() has not been called.&#10;    // Probably the server closed the connection.&#10;    send('connected', false);&#10;    // Reconnect if reconnectOnClose is true.&#10;    if (getParameter('reconnectOnClose')) {&#10;      // Use 'this' rather than 'export' so initialize() can be overridden.&#10;      this.initialize();&#10;    } else {&#10;      // Not set to reconnect on close.&#10;      // Close and unregister everything.&#10;      client.removeAllListeners('open');&#10;      client.removeAllListeners('message');&#10;      client.removeAllListeners('close');&#10;      client = null;&#10;    }&#10;  }&#10;}&#10;  &#10;/** Send the message received from web socket to the 'received' output. */&#10;exports.onMessage = function(message) {&#10;   console.log(&quot;RCVD: &quot;+ JSON.stringify(message));&#10;   send('received', message);&#10;}&#10;  &#10;/** Close the web socket connection. */&#10;exports.wrapup = function() {&#10;  if (inputHandle != null) {&#10;    removeInputHandler(inputHandle);&#10;    inputHandle = null;&#10;  }&#10;  if (client) {&#10;    client.removeAllListeners('open');&#10;    client.removeAllListeners('message');&#10;    client.removeAllListeners('close');&#10;    client.close();&#10;    console.log('Status: Connection closed in wrapup.');&#10;    client = null;&#10;  }&#10;}&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="/Users/oldilge/Documents/eclipseWorkspace/ptII/org/terraswarm/accessor/accessors/web/WebSocketClient.js">
        </property>
        <property name="checkoutOrUpdateAccessorsRepository" class="ptolemy.actor.parameters.SharedParameter" value="true">
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="localhost">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8080">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[745.0, -195.0]">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor sends and/or receives messages from a web socket at&#10; the specified host and port. In &lt;code&gt;initialize()&lt;/code&gt;, it&#10; begins connecting to the web socket server.&#10; Once the connection is established, a &lt;code&gt;true&lt;/code&gt; boolean is sent to&#10; the &lt;code&gt;connected&lt;/code&gt; output.&#10; If connection is not established immediately, the accessor will attempt to&#10; reconnect (numberOfRetries) times at an interval of (reconnectInterval)&lt;/p&gt;&#10;&lt;p&gt; Whenever an input is received on the &lt;code&gt;toSend&lt;/code&gt;&#10; input, the message is sent to the socket. If the socket is not yet open,&#10; this accessor will, by default, queue the message to send when the socket opens,&#10; unless the &lt;code&gt;discardMessagesBeforeOpen&lt;/code&gt; parameter is true, in which case,&#10; input messages that are received before the socket is opened will be&#10; discarded. If messages are queued and &lt;code&gt;throttleFactor&lt;/code&gt; is non-zero, then&#10; whenever a message is queued to be later sent, the accessor will stall&#10; by a number of milliseconds given by the queue size times the throttleFactor.&#10; The longer the queue, the longer the stall. Note that this will likely block&#10; the host from executing, so this feature should be used with caution.&lt;/p&gt;&#10;&lt;p&gt; Whenever a message is received from the socket, that message is&#10; produced on the &lt;code&gt;'received'&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; connection.&lt;/p&gt;&#10;&lt;p&gt; If the connection is dropped midway, the client will attempt to reconnect if &#10; (reconnectOnClose) is true. This does not apply when the accessor wraps up. &lt;/p&gt;&#10;&lt;p&gt; The data can be any type that has a JSON representation.&#10; For incoming messages, this accessor assumes that the message is&#10; a string in UTF-8 that encodes a JSON object.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;h1&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&lt;/h1&gt;&lt;p&gt;   been sent, either because the socket has not yet been opened or because&#10;   it was closed from the other side.&lt;/p&gt;&#10;&lt;h1&gt;Second, a message might be received from the server after shutdown has commenced.&lt;/h1&gt;&lt;p&gt;   In particular, received messages are handled asynchronously by a handler function&#10;   that can be invoked at any time, and that handler might be invoked after it is no&#10;   longer possible for this accessor to produce outputs (it has entered its wrapup&#10;   phase of execution).&lt;/p&gt;&#10;&lt;p&gt; The server might similarly lose messages by the same two mechanisms occurring&#10; on the server side. In that case, messages will presumably be displayed on the&#10; server side.&lt;/p&gt;&#10;&lt;p&gt; Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10; to customize what is sent. See &lt;code&gt;RosPublisher.js&lt;/code&gt; for an example.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the 'webSocket' module.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Hokeun Kim, Marcus Pan, Edward A. Lee, Matt Weber">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$Id: WebSocketClient.js 245 2015-08-04 18:32:13Z matt.weber $">
            </property>
            <property name="server (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;string&quot;]}) The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) The port that the web socket listens to. Defaults to 8080.">
            </property>
            <property name="numberOfRetries (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) The number of times to retry if a connection fails. Defaults to 5.">
            </property>
            <property name="timeBetweenRetries (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) The time between retries in milliseconds. Defaults to 100.">
            </property>
            <property name="reconnectOnClose (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;boolean&quot;]}) The option of whether or not to reconnect when disconnected.">
            </property>
            <property name="discardMessagesBeforeOpen (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;boolean&quot;]}) If true, then any messages received on `toSend` before the socket is open will be discarded. This defaults to false.">
            </property>
            <property name="throttleFactor (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) If non-zero, specifies a time (in milliseconds) to stall when a message is queued because the socket is not yet open. The time of the stall will be the queue size (after adding the message) times the throttleFactor. This defaults to 0.">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="undefined The data to be sent over the socket.">
            </property>
            <property name="connected (port)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;boolean&quot;]}) Output `true` on connected and `false` on disconnected.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="undefined The data received from the web socket server.">
            </property>
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_type" class="ptolemy.actor.TypeAttribute" value="string">
            </property>
        </port>
    </entity>
    <entity name="EndOfSegment" class="ptolemy.actor.lib.SingleEvent">
        <property name="time" class="ptolemy.data.expr.Parameter" value="stopAt">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{270.0, -195.0}">
        </property>
    </entity>
    <entity name="Expression3" class="ptolemy.actor.lib.Expression">
        <property name="expression" class="ptolemy.kernel.util.StringAttribute" value="{}">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="expression">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="60">
            </property>
            <property name="displayHeight" class="ptolemy.data.expr.Parameter" value="10">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{420.0, -195.0}">
        </property>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_type" class="ptolemy.actor.TypeAttribute" value="arrayType(int)">
            </property>
        </port>
        <port name="in" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="ApplauseScore" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;exports.setup = function() {&#10;  input('input');&#10;  output('output');&#10;}&#10;var init=true;&#10;exports.fire = function() {&#10;  var token = get('input'); &#10;if (init){&#10; send('output', token);&#10;init = false;&#10;}&#10;}">
            <property name="style" class="ptolemy.actor.gui.style.TextStyle">
                <property name="height" class="ptolemy.data.expr.Parameter" value="16">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="80">
                </property>
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{885.0, -185.0}">
        </property>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RosPublisher" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor advertises and publishes to a ROS topic. It extends the WebSocketClient to communicate to a rosbridge websocket. &lt;br&gt;&#10; * During intialize, it will advertise the  topic it will publish to, along with its type. The purpose of 'advertise' here is to establish the ROS topic if isn't already established. This is slightly different from the 'advertise' function in NodeHandle which simply publicizes that the the node will be publishing messages to the topic. &#10; * &lt;li&gt;If the topic does not already exist, and the type is valid, a topic will be established with this type.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists with a different type, no new topic will be established&#10; * &lt;li&gt;If the topic already exists with the same type, no new topic will be established.&lt;/li&gt; &#10; * &lt;li&gt;If the topic already exists but the type isn't resolved, no new topic will be established.&lt;/li&gt;&#10; *  On input from 'toSend', this accessor publishes that input to the &#10; *  aforementioned topic. &#10; *  The input from 'toSend' must be in JSON form, and must match the message&#10; *  datatype that the ROS topic is expecting. For example if ROS topic is &#10; *  expecting &lt;code&gt;std_msgs/String&lt;/code&gt;, then the input in 'toSend' should be&#10; *  as follows:&#10; *  &lt;pre&gt; { &quot;data&quot;: &quot;hello world&quot; } &lt;/pre&gt;&#10; *  Some ROS types contain a header which consists of a sequence, timestamp, and a frame_id. If the ROS type has a header, you can either:&#10; *  &lt;li&gt;send the message on toSend without the header, and check the parameter 'addHeader'. This sends the message with a header with only the frame_id specified, and rosbridge will add the sequence and timestamp for you. &#10; *  &lt;li&gt;send a fully formed message with all fields in the header included and don't check the parameter 'addHeader'.&lt;/li&gt; &#10; *  This accessor doesn't do any error checking. All error messages orginate from rosbridge and will appear on the console running rosbridge. More information ccan be viewed on the &lt;a href='https://github.com/RobotWebTools/rosbridge_suite/blob/groovy-devel/ROSBRIDGE_PROTOCOL.md'&gt;rosbridge protocol specification&lt;/a&gt; site.&#10; *&#10; *  @accessor RosPublisher&#10; *  @parameter {string} topic The ROS topic to publish to.&#10; *  @parameter {string} ROStype The ROS datatype of the topic.&#10; *  @parameter {boolean} addHeader If (true), this accessor will send a header with a blank seq and timestamp field, and rosbridge will add the header for you.&#10; *  @parameter {string} frame_id The frame_id of the header (only needed if a header is required).&#10; *  @author Marcus Pan &#10; *  @version $$Id: RosPublisher.js 214 2015-07-13 14:13:36Z mpanj@seas.upenn.edu $$ &#10; */&#10;&#10;&#10;/** Sets up by accessor by inheriting inputs from setup() in WebSocketClient. Adds additional parameters regarding the ROS topic to publish to. */ &#10;exports.setup = function() {&#10;   extend('WebSocketClient');&#10;   parameter('topic', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('ROStype', {&#10;      type: &quot;string&quot;&#10;   });&#10;   parameter('addHeader', {&#10;      type: &quot;boolean&quot;,&#10;      value: false&#10;   });&#10;   parameter('frame_id', {&#10;      type: &quot;string&quot;,&#10;      value: &quot;&quot;&#10;   });&#10;}&#10;&#10;/** Override inputHandler on 'toSend' from WebSocketClient */&#10;exports.toSendInputHandler = function() {&#10;   var msg = get('toSend');&#10;//add a header with a blank time and sequence info. This will be added by rosbridge.&#10;   if (getParameter('addHeader')) {&#10;      msg.header = {&#10;         &quot;frame_id&quot;: getParameter('frame_id')&#10;      };&#10;   }&#10;      &#10;   var data = {&#10;      &quot;op&quot;: &quot;publish&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;msg&quot;: msg &#10;   }&#10;&#10;   exports.sendToWebSocket(data);&#10;}&#10;&#10;/**  Inherits initialize from WebSocketClient. &#10; *   Advertise the topic we are publishing to.*/ &#10;exports.initialize = function() {&#10;   this.ssuper.initialize.apply(this);&#10;&#10;   var advertise = {&#10;      &quot;op&quot;: &quot;advertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic'),&#10;      &quot;type&quot;: getParameter('ROStype')&#10;   };&#10;   exports.sendToWebSocket(advertise);&#10;   &#10;}&#10;&#10;/** Unadvertise the topic and inherit wrapup from WebSocketClient */&#10;exports.wrapup = function() {&#10;   var unadvertise = {&#10;      &quot;op&quot;: &quot;unadvertise&quot;,&#10;      &quot;topic&quot;: getParameter('topic')&#10;   };&#10;   exports.sendToWebSocket(unadvertise);&#10;   this.ssuper.wrapup();&#10;}&#10;&#10;&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://www.terraswarm.org/accessors/RosPublisher.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor advertises and publishes to a ROS topic. It extends the WebSocketClient to communicate to a rosbridge websocket. &lt;br&gt;&#10;During intialize, it will advertise the  topic it will publish to, along with its type. The purpose of 'advertise' here is to establish the ROS topic if isn't already established. This is slightly different from the 'advertise' function in NodeHandle which simply publicizes that the the node will be publishing messages to the topic. &lt;/p&gt;&#10;&lt;p&gt;&lt;li&gt;If the topic does not already exist, and the type is valid, a topic will be established with this type.&lt;/li&gt; &lt;/p&gt;&#10;&lt;p&gt;&lt;li&gt;If the topic already exists with a different type, no new topic will be established&lt;/p&gt;&#10;&lt;p&gt;&lt;li&gt;If the topic already exists with the same type, no new topic will be established.&lt;/li&gt; &lt;/p&gt;&#10;&lt;p&gt;&lt;li&gt;If the topic already exists but the type isn't resolved, no new topic will be established.&lt;/li&gt;&#10; On input from 'toSend', this accessor publishes that input to the &#10; aforementioned topic. &#10; The input from 'toSend' must be in JSON form, and must match the message&#10; datatype that the ROS topic is expecting. For example if ROS topic is &#10; expecting &lt;code&gt;std_msgs/String&lt;/code&gt;, then the input in 'toSend' should be&#10; as follows:&#10; &lt;pre&gt; { &amp;quot;data&amp;quot;: &amp;quot;hello world&amp;quot; } &lt;/pre&gt;&#10; Some ROS types contain a header which consists of a sequence, timestamp, and a frame_id. If the ROS type has a header, you can either:&#10; &lt;li&gt;send the message on toSend without the header, and check the parameter 'addHeader'. This sends the message with a header with only the frame_id specified, and rosbridge will add the sequence and timestamp for you. &#10; &lt;li&gt;send a fully formed message with all fields in the header included and don't check the parameter 'addHeader'.&lt;/li&gt; &#10; This accessor doesn't do any error checking. All error messages orginate from rosbridge and will appear on the console running rosbridge. More information ccan be viewed on the &lt;a href='https://github.com/RobotWebTools/rosbridge_suite/blob/groovy-devel/ROSBRIDGE_PROTOCOL.md'&gt;rosbridge protocol specification&lt;/a&gt; site.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Marcus Pan">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$Id: RosPublisher.js 214 2015-07-13 14:13:36Z mpanj@seas.upenn.edu $">
            </property>
            <property name="topic (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;string&quot;]}) The ROS topic to publish to.">
            </property>
            <property name="ROStype (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;string&quot;]}) The ROS datatype of the topic.">
            </property>
            <property name="addHeader (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;boolean&quot;]}) If (true), this accessor will send a header with a blank seq and timestamp field, and rosbridge will add the header for you.">
            </property>
            <property name="frame_id (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;string&quot;]}) The frame_id of the header (only needed if a header is required).">
            </property>
        </property>
        <property name="server" class="ptolemy.data.expr.StringParameter" value="localhost">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8080">
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="topic" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="ROStype" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="addHeader" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="frame_id" class="ptolemy.data.expr.StringParameter" value="">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1005.0, -175.0]">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
    </entity>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="{225.0, -285.0}">
        </vertex>
        <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;Expression.in&quot;,x=270.0,y=-285.0}, tail={id=&quot;relation3.vertex1&quot;,x=225.0,y=-285.0}, points={} },{ head={id=&quot;ExtractFeatures.port_1&quot;,x=145.0,y=-285.0}, tail={id=&quot;relation3.vertex1&quot;,x=225.0,y=-285.0}, points={} },{ head={id=&quot;CreateGMTKFeatureVector.input&quot;,x=375.0,y=-285.0,index=2}, tail={id=&quot;relation3.vertex1&quot;,x=225.0,y=-285.0}, points={335.0,-290.0,335.0,-335.0,225.0,-335.0} } }">
        </property>
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;Expression.output&quot;,x=270.0,y=-285.0}, tail={id=&quot;CreateGMTKFeatureVector.input&quot;,x=375.0,y=-285.0,index=2}, points={} } }">
        </property>
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;CreateGMTKFeatureVector.output&quot;,x=375.0,y=-285.0}, tail={id=&quot;Merge.input&quot;,x=560.0,y=-195.0,index=2}, points={525.0,-285.0,525.0,-200.0} } }">
        </property>
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;TokenToJSON.input&quot;,x=625.0,y=-195.0}, tail={id=&quot;Merge.output&quot;,x=560.0,y=-195.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;DiscreteClock.output&quot;,x=-65.0,y=-285.0}, tail={id=&quot;AudioCapture.trigger&quot;,x=45.0,y=-285.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;ExtractFeatures.port_4&quot;,x=145.0,y=-285.0}, tail={id=&quot;AudioCapture.output&quot;,x=45.0,y=-285.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;Merge.input&quot;,x=560.0,y=-195.0,index=2}, tail={id=&quot;Expression3.output&quot;,x=420.0,y=-195.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
        <property name="_layoutHint" class="ptolemy.vergil.basic.layout.kieler.LayoutHint" value="{ { head={id=&quot;EndOfSegment.output&quot;,x=270.0,y=-195.0}, tail={id=&quot;Expression3.in&quot;,x=420.0,y=-195.0}, points={} } }">
        </property>
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation11" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="FeatureExtraction.port_1" relation="relation3"/>
    <link port="FeatureExtraction.port_4" relation="relation7"/>
    <link port="DiscreteClock.output" relation="relation8"/>
    <link port="Expression.output" relation="relation"/>
    <link port="Expression.in" relation="relation3"/>
    <link port="CreateGMTKFeatureVector.input" relation="relation3"/>
    <link port="CreateGMTKFeatureVector.input" relation="relation"/>
    <link port="CreateGMTKFeatureVector.output" relation="relation10"/>
    <link port="TokenToJSON.input" relation="relation4"/>
    <link port="TokenToJSON.output" relation="relation6"/>
    <link port="Merge.input" relation="relation10"/>
    <link port="Merge.input" relation="relation2"/>
    <link port="Merge.output" relation="relation4"/>
    <link port="AudioCapture.trigger" relation="relation8"/>
    <link port="AudioCapture.output" relation="relation7"/>
    <link port="WebSocketClient.toSend" relation="relation6"/>
    <link port="WebSocketClient.received" relation="relation9"/>
    <link port="EndOfSegment.output" relation="relation5"/>
    <link port="Expression3.output" relation="relation2"/>
    <link port="Expression3.in" relation="relation5"/>
    <link port="ApplauseScore.input" relation="relation9"/>
    <link port="ApplauseScore.output" relation="relation11"/>
    <link port="RosPublisher.toSend" relation="relation11"/>
</entity>
